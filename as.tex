%\\\\\\\\\\\\!TEX root = tp2.tex

\section{CampusSeguro}

\subsection{Interfaz}

\sexc{AS}
$\textbf{usa}$  
\generos{as}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Interfaz}

\sexc{CampusSeguro}
$\textbf{usa}$  
\generos{CampusSeguro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{campus}{in cs: campusSeguro }{res : campus}
 {true}
 {$\var{res} \igobs campus(cs)$}
 {Devuelve el campus del campusSeguro ingresado.}
 {O($1$)}
 {}
 
\operacion{estudiantes}{in cs: campusSeguro }{res : conj(nombre)}
 {true}
 {$\var{res} \igobs estudiantes(cs)$}
 {Devuelve un conjunto con los estudiantes del campusSeguro ingresado.}
 {O($1$)}
 {}
 
\operacion{hippies}{in cs: campusSeguro }{res : conj(nombre)}
 {true}
 {$\var{res} \igobs hippies(cs)$}
 {Devuelve un conjunto con los hippies del campusSeguro ingresado.}
 {O($1$)}
 {}

\operacion{agentes}{in cs: campusSeguro }{res : conj(agentes)}
 {true}
 {$\var{res} \igobs agentes(cs)$}
 {Devuelve un conjunto con los agentes del campusSeguro ingresado.}
 {O($1$)}
 {}
 
\operacion{PosicionEstudiantesYHippies}{in id: nombre, cs: campusSeguro }{res : posicion}
 {$id \in (estudiantes(cs) \cup hippies(cs))$}
 {$\var{res} \igobs posEstudianteYHippie(id, cs)$}
 {Devuelve la posicion del estudiante o hippie ingresado.}
 {O($|n_m|$)}
 {}

\operacion{PosicionAgente}{in a: agente, cs: campusSeguro }{res : posicion}
 {$a \in agentes(cs)$}
 {$\var{res} \igobs posAgente(a, cs)$}
 {Devuelve la posicion del agente ingresado.}
 {O($1$)}
 {}
 
\operacion{CantidadSanciones}{in a: agente, cs: campusSeguro }{res : nat}
 {$a \in agentes(cs)$}
 {$\var{res} \igobs cantSanciones(a, cs)$}
 {Devuelve la cantidad de sanciones del agente ingresado.}
 {O($1$)}
 {}
 
\operacion{CantidadHippiesAtrapados}{in a: agente, cs: campusSeguro }{res : nat}
 {$a \in agentes(cs)$}
 {$\var{res} \igobs cantHippiesAtrapados(a, cs)$}
 {Devuelve la cantidad de hippies atrapados por el agente ingresado.}
 {O($1$)}
 {}
 
 %%%%%% generadores %%%%%%%

\operacion{comenzarRastrillaje}{in c: campus, d: dicc(agente posicion) }{res : campusSeguro}
{$(\paratodo{agente}{a})(def?(a, d) \impluego (posValida?(obtener(a, d)) \land \neg ocupada?(obtener(a, d), c))) \land $\\$ (\paratodo{agente}{a, a2}) ((def?(a, d) \land def?(a2, d) \land a \neq a2) \impluego obtener(a, d) \neq obtener(a2, d)$}
{$\var{res} \igobs comenzarRastrillaje(c, d)$}
{Crea un nuevo campusSeguro con campus y los agentes ingresados.}
{O($1$)}
{}
 
\operacion{ingresarEstudiante}{in e: nombre, p: posicion, in/out cs: campusSeguro }{}
{$\var(cs) \equiv \var(cs_0) \land e \notin (estudiantes(cs) \cup hippies(cs)) esIngreso?(p, campus(cs)) \land $\\$\neg estaOcupada?(p, cs))$}
{$\var{res} \igobs ingresarEstudiante(e, p, cs_0)$}
{Ingresa un nuevo estudiante al campus por una de las entradas.}
{O($|n_m|$)}
{}

\operacion{ingresarHippie}{in h: nombre, p: posicion, in/out cs: campusSeguro }{}
{$\var(cs) \equiv \var(cs_0) \land h \notin (estudiantes(cs) \cup hippies(cs)) esIngreso?(p, campus(cs)) \land $\\$\neg estaOcupada?(p, cs))$}
{$\var{res} \igobs ingresarHippie(e, p, cs_0)$}
{Ingresa un nuevo hippie al campus por una de las entradas.}
{O($|n_m|$)}
{}

\operacion{moverEstudiante}{in e: nombre, d: direccion, in/out cs: campusSeguro }{}
{$\var(cs) \equiv \var(cs_0) \land e \in estudiantes(cs) \land (seRetira(e, d, cs) \lor $\\$ (posValida?(proxPosicion(posEstudianteYHippie(e, cs), d, campus(cs)), campus(cs)) \land $\\$ \neg estaOcupada?(proxPosicion(posEstudianteYHippie(e, cs), d, campus(cs)), cs)))$}
{$\var{res} \igobs moverEstudiante(e, d, cs_0)$}
{Mueve un estudiante en la direccion indicada.}
{O($|n_m|$)}
{}

\operacion{moverHippie}{in h: nombre, in/out cs: campusSeguro }{}
{$\var(cs) \equiv \var(cs_0) \land h \in hippies(cs) \land $\\$ \neg todasOcupadas?(vecinos(posEstudianteYHippie(h, cs), campus(cs)), cs)$}
{$\var{res} \igobs moverHippie(h, cs_0)$}
{Mueve un hippie hacia el estudiante más cercano.}
{O($|n_m| + N_e$)}
{}


\operacion{moverAgente}{in a: nombre, in/out cs: campusSeguro }{}
{$\var(cs) \equiv \var(cs_0) \land a \in agentes(cs) \yluego cantSanciones(a, cs) \leq 3 \land $\\$ \neg todasOcupadas?(vecinos(posAgente(a, cs), campus(cs)), cs)$}
{$\var{res} \igobs moverAgente(a, cs_0)$}
{Mueve un agente hacia el hippie más cercano.}
{O($|n_m| + log N_a + N_h$)}
{}

\operacion{CantidadHippies}{in cs: campusSeguro }{res : nat}
 {true}
 {$\var{res} \igobs cantHippies(cs)$}
 {Devuelve la cantidad de hippies en el campus.}
 {O($1$)}
 {}
 
\operacion{CantidadEstudiantes}{in cs: campusSeguro }{res : nat}
 {true}
 {$\var{res} \igobs cantEstudiantes(cs)$}
 {Devuelve la cantidad de estudiantes en el campus.}
 {O($1$)}
 {}
 
 \operacion{MásVigilante}{in cs: campusSeguro }{res : agente}
 {true}
 {$\var{res} \igobs masVigilante(cs)$}
 {Devuelve al agente con más capturas realizadas del campus.}
 {O($1$)}
 {}

Las complejidades están en función de las siguientes variables:\\
$c$ : es una instancia del campusSeguro, \\
$p$ : es una posición, \\
$n$ : es el nombre de un estudiante/hippie y $|n_m|$ es la longitud más larga entre todos los nombres del campusSeguro, \\
$d$ : es una dirección, \\
$N_a$ : es la cantidad de agentes, \\
$N_e$ : es la cantidad actual de estudiantes, \\
$N_h$ : es la cantidad actual de hippies. \\
\\ \\

 
Las complejidades están en función de las siguientes variables:\\
$n$ : la cantidad total de computadoras que hay en el sistema, \\
$L$ : el hostname más largo de todas las computadoras, \\
$k$ : la cola de paquetes más larga de todas las computadoras. 
\\ \\



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representación}

\serc{sistema}{
  \\
  \donde{sistema}{\tupla{
      CampusEstatico: \mbox{Campus},
      Campus : \mbox{arreglo(arreglo(\tupla{hayHippie: bool, hayEst: bool, hayAgente: bool, hayObst:bool, pl:itLista(agente), estudiante:itDPN(\tupla{nombre:string,pos:pos}), hippie:itDPN(\tupla{nombre:String,pos:pos})}))},
      estudiantes: \mbox{DiccPorNombre(nombre:string, pos:pos)},
      hippies: \mbox{DiccPorNombre(nombre:string, pos:pos)},
      agentes: \mbox{DiccSuperRapido(pl:nat,\tupla{pos:pos,cantSanc:nat,cantCapturas:nat,mismas:itLista(conMismasBucket),miUbicacion:itLista(agente)})},
      masVigilante: \mbox{placa:nat},
      porSanciones: \mbox{Lista(conMismasBucket)},
      conKSanciones: \mbox{arreglo(\tupla{ocurrioSancion:bool,porKSanc:conj(agente),\#Sanciones:nat})}
    }
  }
  \donde{conMismasBucket}{
      \tupla{
            agentes:\mbox{Conj(agente)},
            \#Sanc:\mbox{nat}
        }
     }
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
  \item En cada posicion de campus hay como m\'aximo una entidad (agente, estudiante, hippie, obstaculo)
  \item Si hayEst, hayHippie o hayAgente es true en alguna posici\'on, entonces el iterador correspondiente debe tener siguiente y apuntar a un lugar en el contenedor correspondiente
  \item No puede haber dos iteradores que apunten a lo mismo
  \item La cantidad de agentes, hippies y estudiantes en campus debe ser igual al tamaño de su correspondiente contenedor
  \item MasVigilante es el que mas hippiesCapturados tiene. En caso de empate, el que mayor nro de placa tiene
  \item El conjunto de todos los agentes en porSanciones es igual a las claves del dicc de agentes
  \item Si ocurrio sancion, el conjunto de agentes formado por la uni\'on de los conjuntos en cada posicion de conkSanciones es igual a las claves del dicc de agentes
  \item porSanciones est\'a ordenado por \#sanciones y en caso de empate por nro de placa
  \item Si ocurrio sancion, entonces, conKSanciones es 'una copia' (sin iteradores y pasando de lista de agentes a conj) de la lista de porSanciones
  \item conKSanciones es\'a ordenado por \#sanciones y en caso de empate por nro de placa


\end{enumerate}

\rep{sistema}{s}  \\
%\subsubsection*{Función de abstracción}
 %\abs{sistema}{sist}{dcnet}{s} \\
%$(\fun{s.} = \NULL \land \fun{*r.der} = \NULL \ssi nil?(a)) \ \oluego$ \\

% $\fun{*r.izq} = izq(a) \land \fun{*r.der} = der(a) \ \land$
%$r.val = raiz(a) $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection*{Funci\'on de abstracción}

\abs{dcnet}{DCNet}{s}{dc} \\
$red(dc)=$*$(s.red) \land (\forall c:compu, c\in compus(dc))( enEspera(dc,c)=$*$(enEspera(s,c)) \land$ \\
$  cantidadEnviados(dc,c)=cantidadEnviados(s,c)) \land $ \\ 
$(\forall p:paquete,paqueteEnTransito?(dc,p)) caminoRecorrido(dc,p)=$*$(caminoRecorrido(s,p)) $

\newpage

\subsection{Algoritmos}

\algoritmo{campus}{in as:as}{res:campus}{
  \State $res \larr as.campus$ \complejidad{O(1)}
}{O(1)}

\algoritmo{agentes}{in as:as}{res:itDiccSuperRapido(agente)}{
  \State $res \larr CrearItSuperRapido(as.agentes)$ \complejidad{O(1)}
}{O(1)}

\algoritmo{estudiantes}{in as:as}{res:itDPN(<estudiante:String,pos:pos>)}{
  \State $res \larr CrearItDPN(as.estudiantes)$ \complejidad{O(1)}
}{O(1)}

\algoritmo{hippies}{in as:as}{res:itDPN(<hippie:String,pos:pos>)}{
  \State $res \larr CrearItDPN(as.estudiantes)$ \complejidad{O(1)}
}{O(1)}

\algoritmo{posEstudiantesYHippies}{in as:as, in nombre:string}{res:pos}{
  \If {$as.estudiantes.definido?(nombre)$} \complejidad{O(long(nombre))}
    \State $return$ $res \larr as.estudiantes.obtener(nombre)$  \complejidad{O(long(nombre))}
  \EndIf
  \If {$as.hippies.definido?(nombre)$}  \complejidad{O(long(nombre))}
    \State $return$ $res \larr as.hippies.obtener(nombre)$  \complejidad{O(long(nombre))}
  \EndIf
 }{O(long(nombre))}

 \algoritmo{posAgente}{in as:as, in placa:agente}{res:pos}{
    \State $res \larr as.agentes.dameS(placa).pos$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}

  \algoritmo{cantSanciones}{in as:as, in placa:agente}{res:pos}{
    \State $res \larr as.agentes.dameS(placa).cantSanciones$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}

  \algoritmo{cantHippiesAtrapados}{in as:as, in placa:agente}{res:pos}{
    \State $res \larr as.agentes.dameS(placa).cantHippiesAtrapados$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}

  \algoritmo{ingresarEstudiante}{in/out as:as, in nombre:string, in pos:pos}{}{
    % Para cada agente 'a' alrededor de un vecino hippie que quedo atrapado: AtraparHippie(a,p)
    % Sancionar a todos los agentes vecinos de los estudiantes vecinos encerrados
    % Convertir a los hippies que quedaron encerrados por 4 estudiantes o eliminar a los que quedaron atrapados por agentes
    
    
    % Si quedo atrapado: Sancionar a los agentes que estan alrededor
    % Si se hippifica:
        % Si hippieAtrapado: - Para todos los agentes vecinos 'a': AtraparHippie(a,p) 
        % Sino: Agregar hippie al diccionario de hippies
    % Sino: Agregar el estudiante al diccionario de estudiantes


    %%% Operaciones auxiliares faltantes:
    %%%     - obtenerVecinos: retorna las posiciones vecinas de una posicion (Puede ser de campus, pero creo que campus solo deberia ser una matriz estatica)
    %%%     - atrapadoPorAgente?: Indica si una posicion fue atrapada por agentes (hay al menos un agente entre los que lo rodean)
    %%%     - sancionarAgente: La operacion mas compleja, actualiza porSanciones y el hash de agentes
    %%%     - hippieAEst?: Indica si un hippie esta completamente rodeado por estudiantes, en ese caso se convierte a estudiante

    %%
    \State $as.agregarEstudiante(as, pos, nombre)$ \complejidad{O(long(nombre))}


    %% Sanciono a los agentes que rodean a los estudiantes atrapados al ingresar uno nuevo
    \State // Sanciono a los agentes que rodean a los estudiantes atrapados al ingresar uno nuevo
    \State $as.sancionarAgentesVecinos(as,pos)$ \complejidad{O(1)}
    \\
    \\
    %%%% TODO: Hippificarlo: Ver especificacion
    \State // Hippificar al estudiante
    \If {$as.estAHippie?(as,pos)$}
      \State $as.hippificar(as,pos)$ \complejidad{O(long(nombre))}
    \EndIf
    \\
    \\
    %%%% Convertir a los hippies que quedaron encerrados por 4 estudiantes o eliminar a los que quedaron atrapados por agentes
    %%%% Funciona bien porque los vecinos de una posicion no son vecinos entre ellos
    \State // Convertir a los hippies vecinos que quedaron encerrados por 4 estudiantes o eliminar a los que quedaron atrapados por agentes
    \State $as.aplicarHippiesVecinos(as,pos)$ \complejidad{O(long(nombre))}
    \\
    %%%% TODO: Si hay hippie: Capturar hippie en pos actual
    \If {$as.campus[pos.x][pos.y].hayHippie?$} 
        \State $capturarHippie(pos)$ \complejidad{O(long(nombre))}
    \EndIf
 }{O(long(nombre))}
 
  \algoritmo{ComenzarRastrillaje}{in/out as:as, in ce:CampusEstatico, in Agentes:dicc(placa pos)}{}{

  \State $as.CampusEstatico \larr ce$ \complejidad{O(1)}
  \State $ItAgentes \larr CrearItAgentes(Agentes)$ \complejidad{O(1)}
  \State $i \larr 0$ \complejidad{O(1)}
  \State $j \larr 0$ \complejidad{O(1)}
  
  \While {$i < ce.Ancho $} \complejidad{O(Ancho)}
    \While {$j < ce.Alto $} \complejidad{O(Alto)}
      \State $as.Campus[i][j].HayHippie \larr False$\complejidad{O(1)}
      \State $as.Campus[i][j].HayEst \larr False$\complejidad{O(1)}
      \State $as.Campus[i][j].HayObst \larr ce.Obstaculos[i][j]$\complejidad{O(1)}
      \State $i \larr i+1$\complejidad{O(1)}
      \State $j \larr j+1$\complejidad{O(1)}
    \EndWhile
  \EndWhile

  \State $as.Agentes \larr CrearDiccSuperRapido()$\complejidad{O(1)}
  \State $MayorPlaca \larr 0$\complejidad{O(1)}
  \While {$ItAgente.HaySiguiente$}\complejidad{O(Cantidad Agentes)}
      \State $as.Campus[ItAgentes.Siguiente.pos.X][ItAgentes.Siguiente.pos.Y].HayAgente \larr True$\complejidad{O(1)}
      \State $as.Campus[ItAgentes.Siguiente.pos.X][ItAgentes.Siguiente.pos.Y].Pl \larr $\\$ Definir(as.Agentes, ItAgentes.Siguiente.Pl, 
      %%%%%%%%%%%%% No se como es el tema de tupla cuando es un Definir %%%%%%%%%%%%
      Tupla(Pos \larr ItAgentes.Siguiente.Pos, CantSanciones \larr 0, CantCapturas \larr 0)$\complejidad{O(1)}
      
      \If{$MayorPlaca < ItAgentes.Siguientes.Pl$}
        \State $MayorPlaca \larr ItAgenda.Siguiente.Pl$\complejidad{O(1)}
        \State $MayorAgente \larr ItAgenda.Siguiente$\complejidad{O(1)}
    \EndIf
    \State $ItAgentes.Avanzar$\complejidad{O(1)}
  \EndWhile
  
  \State $as.Estudiante \larr CrearDiccPorNombre()$\complejidad{O(1)}
  \State $as.Hippie \larr CrearDiccPorNombre()$\complejidad{O(1)}
  \State $as.MasVigilante \larr MayorAgente$\complejidad{O(1)}
  \State $as.PorSanciones \larr CrearLista(Tupla<Agentes \larr \varnothing, \#Sanciones \larr 0>$\complejidad{O(1)}
  \State $ItAgentesRapido \larr CrearItAgentesRapido()$ \complejidad{O(1)}
  
  \While{$ItAgentesRapido.HaySiguiente$}\complejidad{O(Cantidad Agentes)}
    \State $ItAgentesRapido.HaySiguiente.MiHubicacion \larr $\\$ as.PorSancion.ObtenerUltimo.Agentes.Agregar(ItAgentesRapido,SiguienteClave)$\complejidad{O(1)}
    \State $ItAgentesRapido.Avanzar$\complejidad{O(1)}
  \EndWhile
    

 }{O($(Ancho*Alto) + N_a$)}

 \algoritmo{moverEstudiante}{in/out as:as, in nombre:String, in dir:direccion}{}{
    \State // PRE: El nombre es una clave del dicc de estudiantes, se retira o (La prox posicion es valida y no esta ocupada)
    \\
    \State // Mover el estudiante
    \State $posVieja \larr as.estudiantes.obtener(nombre)$ \complejidad{O(long(nombre))}
    \State $as.campus[posVieja.x][posVieja.y].hayEst? \larr False$
    \State $as.campus[as.campusEstatico.proxPos(posVieja, dir).x][as.campusEstatico.proxPos(posVieja, dir).y].hayEst \larr True$
    \State $as.campus[as.campusEstatico.proxPos(posVieja, dir).x][as.campusEstatico.proxPos(posVieja, dir).y].estudiante \larr as.campus[posVieja.x][posVieja.y].estudiante$ \complejidad{O(1)}
    \State $as.campus[posVieja.x][posVieja.y].estudiante \larr NULL$ \complejidad{O(1)}
    \State // Sancionar agentes vecinos y a los que encierran a est vecinos
    \State  sancionarAgentesENcerrandoEstVecinos(as, pos) \complejidad{O(1)}
    \State sancionarAgentesVecinos(as,pos) \complejidad{O(1)}
    \State // Convertir a estudiantes los hippies vecinos o capturarlos
    \State aplicarHippiesVecinos(as,pos) \complejidad{O(1)}
  }{O(long(nombre))}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}
 \algoritmo{sancionarAgentesVecinos}{in/out as:as, in pos:pos}{}{
    % Sancionar VECINOS
    \State $vecinos \larr as.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
    \If {$as.atrapadoPorAgente?(pos)$} 
       \While {$i < vecinos.tamanio()$}  \complejidad{O(1)}
           \If {$as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
               \State $as.sancionarAgente(vecinos[i].agente)$ \complejidad{O(1)}
           \EndIf
           \State $i++$
       \EndWhile
    \EndIf
 }{O(1)}

\algoritmo{sancionarAgentesEncerrandoEstVecinos}{in/out as:as, in pos:pos}{}{
   \State $vecinos \larr as.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
   \State $i \larr 0$
   \While {$i < vecinos.tamanio$} \complejidad{O(1)}
      \If {$as.campus[vecinos[i].x][vecinos[i].y].hayEst$ $\land$ $atrapadoPorAgente?(as,pos)$}  \complejidad{O(1)}
          \State $sancionarAgentesVecinos(as,pos)$ \complejidad{O(1)}
      \EndIf
      \State $i++$
    \EndWhile
}{O(1)}

\algoritmo{sancionarAgente}{in/out as:as, in/out agente:itDiccRapido}{}{
    \State $agente.siguiente.cantSanciones$ $\larr$ $agente.siguiente.cantSanciones + 1$ \complejidad{O(1)}
    \State $agente.siguiente.miUbicacion.eliminarSiguiente()$ \complejidad{O(1)}
    \State // El iterador mismas apunta a la posicion correspondiente del agente dentro de la lista ordenada por cantSanciones
    \State // Como la lista en el peor caso puede contener a todos los agentes con igual cant de sanciones
    \State // la mayor cantidad posible de iteraciones del ciclo es 4
    \While {$agente.siguiente.mismas.haySiguiente() \land agente.siguiente.mismas.siguiente.cantSanciones < agente.siguiente.cantSanciones$}
      \State $agente.siguiente.mismas.avanzar()$ \complejidad{O(1)}
    \EndWhile
    \State // Si no hay siguiente o  si la cantidad de sanciones del siguiente es menor que la del agente, entonces, 
    \State // creo un conMismasBucket, lo inserto como siguiente y me guardo el iterador en miUbicacion
    \State // Sino, agrego el agente al conj de agentes del siguiente y me guardo el iterador en miUbicacion
    \If {$\neg(agente.siguiente.mismas.haySiguiente)$ $\lor$
        \\$(agente.siguiente.mismas.haySiguiente \land$\\$agente.siguiente.cantSanciones=agente.siguiente.mismas.cantSanciones)$} \complejidad{O(1)}
      \State $nConMismasB \larr nuevaTupla(CrearNuevoDiccLineal(), agente.siguiente.cantSanciones)$
      \State $agente.siguiente.mismas \larr agente.siguiente.mismas.agregarComoSiguiente(nConMismasB)$ \complejidad{O(1)}
      \State $agente.siguiente.miUbicacion \larr agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
    \Else 
      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
    \EndIf
}{O(1)}

 \algoritmo{atrapadoPorAgente?}{in as:as, in pos:pos}{res:bool}{
    \State $vecinos \larr as.campusEstatico.vecinos(pos)$
    \State $alMenos1Agente \larr False$ \complejidad{O(1)}
    \State $i \larr 0$
    \If {$\neg(encerrado?(pos, as.campusEstatico.vecinos(pos)))$}
      \State $return$ $false$
    \EndIf
    \State // Veo si hay algun agente alrededor
     \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
       \If {$as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
          \State $return$ $true$
        \EndIf
        \State $i++$ \complejidad{O(1)}
    \EndWhile
 }{O(1)}

\algoritmo{hippificar}{in as:as, in pos:pos}{}{
    \State // PRE: La posicion esta en el tablero y hay estudiante en la posicion
    \State $as.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
    \State $as.campus[pos.x][pos.y].hippie.agregarComoSiguiente(nombre, pos)$ \complejidad{O(long(nombreEstudiante))}
    \State $as.campus[pos.x][pos.y].hayEst \larr False$ \complejidad{O(1)}
    \State $as.campus[pos.x][pos.y].estudiante.eliminarSiguiente()$ \complejidad{O(long(nombreEstudiante))}
}{O(long(nombre))}

 \algoritmo{estAHippie?}{in as:as, in pos:pos, in vecinos:arreglo(pos)}{res:bool}{
    \If {$\neg(encerrado?(pos,vecinos))$}
      \State $return$ $false$ \complejidad{O(1)}
    \EndIf
    \State $i$ $\larr$ $0$ \complejidad{O(1)}
    \State $cantHippies$ $\larr$ $0$ \complejidad{O(1)}
    \State $vecinos \larr as.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
    \While {$i < vecinos.tamanio()$}
      \If {$campus[vecinos[i].x][vecinos[i].y].hayHippie$}
        \State $cantHippies++$ \complejidad{O(1)}
      \EndIf
      \State $i++$
    \EndWhile
    \State $return$ $cantHippies \ge 2$ \complejidad{O(1)}
 }{O(1)}

\algoritmo{hippieAEst?}{in as:as, in pos:pos}{res:bool}{
  \State $i$ $\larr$ $0$ \complejidad{O(1)}
  \State $vecinos \larr as.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
  \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
      \If {$\neg(as.campus[vecinos[i].x][vecinos[i].y].hayEst?)$}
        \State $return$ $False$ \complejidad{O(1)}
      \EndIf
  \EndWhile
  \State $return$ $True$
}{O(1)}

 \algoritmo{encerrado?}{in as:as, in pos:pos}{}{
    \State $vecinos \larr vecinos(as.campusEstatico, pos)$ \complejidad{O(1)}
    \State $i \larr vecinos.tamanio()$ \complejidad{O(1)}
    \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
       \If {$\neg(as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$ $\lor$
             \\$as.campus[vecinos[i].x][vecinos[i].y].hayEst?$ $\lor$
             \\$as.campus[vecinos[i].x][vecinos[i].y].hayHippie?$ $\lor$
             \\$as.campus[vecinos[i].x][vecinos[i].y].hayObst?)$} \complejidad{O(1)}
              \State $return$ $false$ \complejidad{O(1)}
        \EndIf
        \State $i++$ \complejidad{O(1)}
    \EndWhile
    \State $return true$
 }{O(1)}

 \algoritmo{aplicarHippiesVecinos}{in/out as:as, in pos:pos}{}{
    \State $vecinos \larr as.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
    \State $i \larr 0$ \complejidad{O(1)}
    \While {$i < vecinos.tamanio()$} \complejidad{O(long(nombre))}
       \State aplicarHippie(as, pos) \complejidad{O(long(nombre))}
    \EndWhile
 }{O(long(nombre))}

 \algoritmo{aplicarHippie}{in/out as:as, in pos:pos}{}{
    \State // PRE: pos valida y hayHippie en as.campus[pos.x][pos.y]
    \If {$as.campus[pos.x][pos.y].hayHippie$}
      \If {$as.hippieAEst(pos)$} \complejidad{O(1)}
          \State $as.campus[pos.x][pos.y].hayHippie \larr False$ \complejidad{O(1)}
          \State $as.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
          \State $as.campus[pos.x][pos.y].hippie \larr CrearIt(as.hippies)$ \complejidad{O(1)}
          \State $as.campus[pos.x][pos.y].hippie.agregarComoSiguiente(as.campus[pos.x][pos.y].estudiante.nombre)$ \complejidad{O(long(nombre))}
          \State $as.campus[pos.x][pos.y].estudiante.eliminarSiguiente()$ \complejidad{O(long(nombre))}
      \Else
        \If {$as.campus[pos.x][pos.y].hayHippie?$ $\land$ $atrapadoPorAgente(pos)$}
            \State $as.campus[pos.x][pos.y].hayHippie? = False$ \complejidad{O(1)}
            \State $as.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
        \EndIf
      \EndIf
    \EndIf
 }{O(long(nombre))}
