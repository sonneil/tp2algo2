%\\\\\\\\\\\\!TEX root = tp2.tex

\section{DCNet}

\subsection{Interfaz}

\sexc{AS}
$\textbf{usa}$  
\generos{as}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


\operacion{crearSistema}{in r: red}{res : dcnet}
 {true}
 {$\var{res} \igobs iniciarDCNet(r)$}
 {Crea un sistema DCNet.}
 {O($L \times n^5$)}
 {res.red es un puntero a la red que recibimos por parámetro}
 
Las complejidades están en función de las siguientes variables:\\
$n$ : la cantidad total de computadoras que hay en el sistema, \\
$L$ : el hostname más largo de todas las computadoras, \\
$k$ : la cola de paquetes más larga de todas las computadoras. 
\\ \\



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representación}

\serc{sistema}{
	\\
	\donde{sistema}{\tupla{
      Campus : \mbox{arreglo(arreglo(\tupla{hayHippie: bool, hayEst: bool, hayAgente: bool, hayObst:bool, pl:itLista(agente), estudiante:itDPN(\tupla{nombre:string,pos:pos}), hippie:itDPN(\tupla{nombre:String,pos:pos})}))},
      estudiantes: \mbox{DiccPorNombre(nombre:string, pos:pos)},
      hippies: \mbox{DiccPorNombre(nombre:string, pos:pos)},
      agentes: \mbox{DiccSuperRapido(pl:nat,\tupla{pos:pos,cantSanc:nat,cantCapturas:nat,mismas:itLista(conMismasBucket),miUbicacion:itLista(agente)})},
      masVigilante: \mbox{placa:nat},
      porSanciones: \mbox{Lista(conMismasBucket)},
      conKSanciones: \mbox{arreglo(\tupla{ocurrioSancion:bool,porKSanc:conj(agente),\#Sanciones:nat})}
    }
	}
  \donde{conMismasBucket}{
      \tupla{
            agentes:\mbox{Lista(agente)},
            \#Sanc:\mbox{nat},
            conMasSanciones:\mbox{itLista(conMismasBucket)},
            conMenosSanciones:\mbox{itLista(conMismasBucket)}
        }
     }
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
  \item En cada posicion de campus hay como m\'aximo una entidad (agente, estudiante, hippie, obstaculo)
  \item Si hayEst, hayHippie o hayAgente es true en alguna posici\'on, entonces el iterador correspondiente debe tener siguiente y apuntar a un lugar en el contenedor correspondiente
  \item No puede haber dos iteradores que apunten a lo mismo
  \item La cantidad de agentes, hippies y estudiantes en campus debe ser igual al tamaño de su correspondiente contenedor
  \item MasVigilante es el que mas hippiesCapturados tiene. En caso de empate, el que mayor nro de placa tiene
  \item El conjunto de todos los agentes en porSanciones es igual a las claves del dicc de agentes
  \item Si ocurrio sancion, el conjunto de agentes formado por la uni\'on de los conjuntos en cada posicion de conkSanciones es igual a las claves del dicc de agentes
  \item porSanciones est\'a ordenado por \#sanciones y en caso de empate por nro de placa
  \item Si ocurrio sancion, entonces, conKSanciones es 'una copia' (sin iteradores y pasando de lista de agentes a conj) de la lista de porSanciones
  \item conKSanciones es\'a ordenado por \#sanciones y en caso de empate por nro de placa


\end{enumerate}

\rep{sistema}{s}  \\
%\subsubsection*{Función de abstracción}
 %\abs{sistema}{sist}{dcnet}{s} \\
%$(\fun{s.} = \NULL \land \fun{*r.der} = \NULL \ssi nil?(a)) \ \oluego$ \\

% $\fun{*r.izq} = izq(a) \land \fun{*r.der} = der(a) \ \land$
%$r.val = raiz(a) $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection*{Funci\'on de abstracción}

\abs{dcnet}{DCNet}{s}{dc} \\
$red(dc)=$*$(s.red) \land (\forall c:compu, c\in compus(dc))( enEspera(dc,c)=$*$(enEspera(s,c)) \land$ \\
$  cantidadEnviados(dc,c)=cantidadEnviados(s,c)) \land $ \\ 
$(\forall p:paquete,paqueteEnTransito?(dc,p)) caminoRecorrido(dc,p)=$*$(caminoRecorrido(s,p)) $

\newpage

\subsection{Algoritmos}

\algoritmo{icrearSistema}{in r:red}{res:dcnet}{
%inicializacion Caminos Minimos
	\State $res.red \larr r$
	\State $n \larr Longitud(\Fun{compus}(red))$ \complejidad{O(1)}
	\State $i\larr 0$
	\State $j\larr 0$
		\complejidad{O(1)}
	\State $res.Compus \larr \Fun{CrearArreglo}(n)$
		\complejidad{O(n)}
	\State $res.CaminosMinimos\larr \Fun{CrearArreglo}(n)$
		\complejidad{O(n)}
	\Var{p: arreglo$\_$dimensionable de puntero(conjLog(paquete))}	
	\While{i$<$n} \complejidad{O($L*n^5$)}
		\complejidad{O(n)}
		\State $res.CaminosMinimos[i] \larr \Fun{CrearArreglo}(n)$ 
			\complejidad{O(n)}
		\State s:$ \ <nat,conjLog(paquete,<_{id}),conjLog(paquete,<_{p}), $\\$ conjLog(paquetePos,<_{id}),conjLog(paquetePos,<_{p}) >$
		%HAY que ver bien donde definir la relacion!!
		\State $\pi_1(s) \larr compu(r,i)$
		\State $\pi_2(s) \larr \Fun{nuevo}()$
		\State $\pi_3(s) \larr \Fun{nuevo}()$
		\State $\pi_4(s) \larr \Fun{nuevo}()$
		\State $\pi_5(s) \larr \Fun{nuevo}()$
		\State \Fun{definir}(res.CompusPorPref,compu(r,i),s)
			\complejidad{O(L)}
		\State $p[i] \larr \pi_3(s)$
		\State $p'[i] \larr \pi_5(s) $
		\State $res.Compus[i] \larr $ $<compu(r,i),p[i],p'[i],0>$ 
			\complejidad{O(1)}
		\While{j$<$n} \complejidad{O($L*n^4$)}
			\complejidad{O(n)}
			\State $res.CaminosMinimos[i][j] \larr caminoMinimo(compu(r,i),compu(r,j),r)$
				\complejidad{O($L*n^3$)}
			\State $j++$
		\EndWhile
		\State $i++$	
	\EndWhile
	\State $res.LaQMasEnvio \larr 0$
		\complejidad{O(1)}
%holi
}
{O($L \times n^5$)}

\algoritmo{icrearPaquete}{in/out s:dcnet,in/out p: paquete}{}{ %hay que cambiar nombres segun heap y avl
  \State $t_1:\ <nat,conjLog(paquete,<_{id}),conjLog(paquete,<_{p}), $\\$ conjLog(paquetePos,<_{id}),conjLog(paquetePos,<_{p}) >$
  \State $t_1 \larr \Fun{Obtener}(origen(p),\ \var{s}.CompusPorPref)$
        \complejidad{O($L$)}
  \State $t_2:\ <nat,conjLog(paquete,<_{id}),conjLog(paquete,<_{p}), $\\$ conjLog(paquetePos,<_{id}),conjLog(paquetePos,<_{p}) >$
  \State $t_2 \larr \Fun{Obtener}(destino(p),\ \var{s}.CompusPorPref)$
  	\complejidad{O($L$)}
  \State $p$'$:paquetePos$ 
  \State $\Fun{indiceOrigen}(p$'$) \larr \pi_1(t_1)$
  	\complejidad{O(1)}
  \State $\Fun{indiceDestino}(p$'$) \larr \pi_1(t_2)$
  	\complejidad{O(1)}
  \State $\Fun{posActual}(p$'$) \larr 0$
  \State \Fun{insertar}($\pi_2(t),p$) %agrega segun nombre
        \complejidad{O($log(k)$)}
  \State \Fun{insertar}($\pi_3(t),p$) %agrega segun prioridad
        \complejidad{O($log(k)$)}
  \State \Fun{insertar}($\pi_4(t),p$') %agrega segun nombre
        \complejidad{O($log(k)$)}
  \State \Fun{insertar}($\pi_5(t),p$') %agrega segun prioridad
        \complejidad{O($log(k)$)}
}
{O($L + log(k)$)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Servicios Usados}
Del modulo ConjLog requerimos \fun{pertenece}, \fun{buscar}, \fun{menor}, \fun{insertar} y \fun{borrar} en O($log(k)$) .

Del modulo Diccionario Por Prefijos requerimos \fun{Def?}, \fun{obtener} en O($L$).
