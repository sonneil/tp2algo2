%\\\\\\\\\\\\!TEX root = tp2.tex

\section{Diccionario Rapido}

Es un diccionario que dado un numero de placa como clave, nos da su significado en promedio O(1)

\subsection{Interfaz}

  \textbf{par\'ametros formales}
  
  \textbf{g\'eneros} Nat, $\alpha$\\

\sexc{Diccionario(Nat,conj($\alpha$))}
\generos{diccR(Nat,conj($\alpha$))}

$\textbf{usa}$  
Bool, Nat, Conjunto($\alpha$)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


\operacion{crear}{in n : nat}{res : diccR(Nat,\alpha)}
 {true}
 {$\#Claves(res) \igobs n$}
 {Crea un diccionario rapido.}
 {O(n)}
 {Completar Aliasing}

\operacion{asignar}{in/out v:diccR(Nat;conj($\alpha$)),in p:nat,in s:$\alpha$}{}
 {$v \igobs v_0$ $\land$ Definido?(p,v)}
 {$Definir(p , Ag(Obtener(p,v_0),s) , v)$}
 {Agrega el valor de s, al significado actual, para la clave dada}
 {O(1)}
 {Completar Aliasing}

\operacion{dameS}{in/out v : diccR(Nat;conj(\alpha)),in p : nat}{res : conj($\alpha$)}
 {Definido?(p,v)}
 {$Obtener(p,v)$}
 {Retorna el significado actual, para la clave dada.}
 {O(1)}
 {Completar Aliasing}
 
Las complejidades est\'an en funci\'on de las siguientes variables:\\
$n$ : la cantidad total de claves, definidas en el diccionario. \\
\\ \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representaci\'on}

\serc{acceso}{
	\\
	\donde{acceso}{claves : arreglo(contenido)}
	\\
	\donde{contenido}{conjl($\alpha$}
}

Aclaraci\'on: cada vez que dice arreglo en esta estructura nos referimos a arreglo\_estatico y conjl es conjunto lineal

\subsubsection*{Invariante de representaci\'on}

\begin{enumerate}
  \item Todos los indices del arreglo, pertenecen al conjunto de claves del diccionario   
		sin repetidos.
  \item Para todos los indices i del arreglo, contenido es igual al significado del   
		diccionario para ese i. 
\end{enumerate}

\rep{acceso}{a}  \\
\begin{enumerate}
 \item 1. \paratodo{Nat}{p} Definido?(a,p) = obtener($\pi_1$(c),s.CompusPorPref)
\end{enumerate}


\subsubsection*{Funci\'on de abstracciÃ³n}

\abs{dcnet}{DCNet}{s}{dc} \\
$red(dc)=$*$(s.red) \land (\forall c:compu, c\in compus(dc))( enEspera(dc,c)=$*$(enEspera(s,c)) \land$ \\
$  cantidadEnviados(dc,c)=cantidadEnviados(s,c)) \land $ \\ 
$(\forall p:paquete,paqueteEnTransito?(dc,p)) caminoRecorrido(dc,p)=$*$(caminoRecorrido(s,p)) $

\subsection{Algoritmos}

\algoritmo{icrear}{in r : Nat}{res:diccR()}{
%inicializacion Caminos Minimos
	\State $i \larr 0$
		\complejidad{O(1)}
	\State $p \larr CrearArreglo(n)$ \complejidad{O(n)}
	\While {$i<n$} \complejidad{O(n)}
		\State $p[i] \larr vacio()$
			\complejidad{O(1)}
		\State $i++$	
			\complejidad{O(1)}
	\EndWhile
	\State $res \larr p$
		\complejidad{O(1)}
}
{O(n)}

\algoritmo{iasignar}{in/out a: acceso , in p : Nat, in s : $\alpha$}{}{
  \State a[FhashPlaca(p,a)] = AgregarRapido(a[FhashPlaca(p,a)],s)
  	\complejidad{O(1)}
}
{O(1)}


\algoritmo{idameS}{in/out a: acceso , in p : Nat}{res : contenido}{
  \State res = a[FhashPlaca(p,a)]
  	\complejidad{O(1)}
}
{O(1)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Servicios Usados}
Del modulo ConjLineal 
