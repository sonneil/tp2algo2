%\\\\\\\\\\\\!TEX root = tp2.tex

\section{Diccionario Rapido}

Es un diccionario que dada un numero de placa como clave, nos da su significado
en O(1)

\subsection{Interfaz}

  \textbf{par\'ametros formales}
  
  \textbf{g\'eneros} Nat, $\alpha$\\

\sexc{Diccionario(Nat,conj($\alpha$))}
\generos{diccR(Nat,conj($\alpha$))}

$\textbf{usa}$  
Bool, Nat, Conjunto($\alpha$)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


\operacion{crear}{in n : nat}{res : diccR(Nat,$\alpha$)}
 {true}
 {$#Claves(res)\igobs n$}
 {Crea un diccionario rapido.}
 {O(n)}
 {Completar Aliasing}

\operacion{asignar}{in/out v : diccR(Nat,conj($\alpha$)),in p : nat,in s : $\alpha$}
 {$v \igobs v_0$ \land Definido?(p,v)
 {$Definir(p , Ag(Obtener(p,v_0),s) , v)$}
 {Agrega el valor de s, al significado actual, para la clave dada.}
 {O(1)}
 {Completar Aliasing}

\operacion{dameS}{in/out v : diccR(Nat,conj($\alpha$)),in p : nat} {res : conj($\alpha$)}
 {Definido?(p,v)
 {$Obtener(p,v)$}
 {Retorna el significado actual, para la clave dada.}
 {O(1)}
 {Completar Aliasing}
 
Las complejidades est\'an en funci\'on de las siguientes variables:\\
$n$ : la cantidad total de claves, definidas en el diccionario. \\
\\ \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representaci\'on}

\serc{acceso}{
	\\
	\donde{acceso}{claves : arreglo(contenido)}
	\\
												\donde{contenido}{conjl($\alpha$}
}

Aclaraci\'on: cada vez que dice arreglo en esta estructura nos referimos a arreglo\_estatico y conjl es conjunto lineal

\subsubsection*{Invariante de representaci\'on}

\begin{enumerate}
  \item Todos los indices del arreglo, pertenecen al conjunto de claves del diccionario   
		sin repetidos.
  \item Para todos los indices i del arreglo, contenido es igual al significado del   
		diccionario para ese i.  

\rep{acceso}{a}  \\
 $1.\ \paratodo{Nat}{p}\ \fun{Definido?(a,p) = \fun{obtener}(\pi_1(c),s.CompusPorPref) $\\

%\subsubsection*{FunciÃ³n de abstracciÃ³n}
 %\abs{sistema}{sist}{dcnet}{s} \\
%$(\fun{s.} = \NULL \land \fun{*r.der} = \NULL \ssi nil?(a)) \ \oluego$ \\

% $\fun{*r.izq} = izq(a) \land \fun{*r.der} = der(a) \ \land$
%$r.val = raiz(a) $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection*{Funci\'on de abstracciÃ³n}

\abs{dcnet}{DCNet}{s}{dc} \\
$red(dc)=$*$(s.red) \land (\forall c:compu, c\in compus(dc))( enEspera(dc,c)=$*$(enEspera(s,c)) \land$ \\
$  cantidadEnviados(dc,c)=cantidadEnviados(s,c)) \land $ \\ 
$(\forall p:paquete,paqueteEnTransito?(dc,p)) caminoRecorrido(dc,p)=$*$(caminoRecorrido(s,p)) $

\newpage

\subsection{Algoritmos}

\algoritmo{icrear}{in r : Nat}{res : acceso}{
%inicializacion Caminos Minimos
	\State $i\larr 0$
		\complejidad{O(1)}
	\Var{p: arreglo$\_$estatico$[n])$ de conjl($\alpha$)}	
	\State $p \larr \Fun{CrearArreglo}(n)$
		\complejidad{O(n)}
	\While{i$<$n} \complejidad{O(n)}
		\State $p[i] \larr \vacio()$
			\complejidad{O(1)}
		\State $i++$	
			\complejidad{O(1)}
	\EndWhile
	\State $res \larr p$
		\complejidad{O(1)}
}
{O(n)}

\algoritmo{iasignar}{in/out a: acceso , in p : Nat, in s : $\alpha$}{}{
  \State a[FhashPlaca(p,a)] = AgregarRapido(a[FhashPlaca(p,a)],s)
  	\complejidad{O(1)}
}
{O(1)}


\algoritmo{idameS}{in/out a: acceso , in p : Nat,}{res : contenido}{
  \State res = a[FhashPlaca(p,a)]
  	\complejidad{O(1)}
}
{O(1)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Servicios Usados}
Del modulo ConjLineal 
